<!DOCTYPE html><html lang="en"><head><title>d2/ch/jarvismarch</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../"><meta name="groc-document-path" content="d2/ch/jarvismarch"><meta name="groc-project-path" content="js/src/d2/ch/jarvismarch.js"><meta name="groc-github-url" content="https://github.com/aureooms/js-cg"><link rel="stylesheet" type="text/css" media="all" href="../../assets/style.css"><script type="text/javascript" src="../../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/aureooms/js-cg/blob/master/js/src/d2/ch/jarvismarch.js">js/src/d2/ch/jarvismarch.js</a></div></div><div id="document"><div class="segment"></div><div class="segment"><div class="comments "><div class="wrapper"><p>From Wikipedia :</p>
<p>Gift wrapping aka Jarvis march — O(nh)
One of the simplest (although not the most time efficient in the worst case)
planar algorithms. Discovered independently by Chand &amp; Kapur in 1970 and
R. A. Jarvis in 1973. It has O(nh) time complexity, where n is the number of
points in the set, and h is the number of points in the hull. In the worst
case the complexity is Θ(n^2).</p>
<p>-&gt; <a href="https://en.wikipedia.org/wiki/Gift_wrapping_algorithm">https://en.wikipedia.org/wiki/Gift_wrapping_algorithm</a></p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> __jarvismarch__ = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( sinsign , cossign )</span> {</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>The idea is to wrap the set of points. The technique is the following.</p>
<p>You first select a vertex for which you are sure that it is part of the
convex hull. For example you can choose the vertex that is first in
lexicographical order over the coordinates in two dimensions, i.e. find
all vertices that have the smallest x coordinate and if there is more
than one then keep only the one with the smallest y coordinate.</p>
<p>From this selected vertex you compute the next one. The next one is
defined as the one that comes after in clockwise order.</p>
<p>   |
   |     In this example u is the selected vertex and v the next one.
   |     v is such that there is no vertex w with sin( u , v , w ) &lt; 0
   u     i.e. lying on the right of uv because otherwise u was not
    \    part of the hull in the first place.
     v</p>
<p>To solve the problem completely we simply iterate over all successive uv
pairs ( we replace u with v after each iteration ). We stop when we made
the complete loop around the set of vertices, i.e when the next v is the
very first u.</p>
<p>Hypotheses:</p>
<ul>
<li>|set| &gt;= 2</li>
<li>set[0] must be part of the hull ( if |set| = 2 this is the
only thing you have to do )</li>
</ul>
<p>Parameters:</p>
<ul>
<li><p><strong>set must be an array.</strong><br/>(is the input vertex set)</p>
</li>
<li><p><strong>hull must be an array.</strong><br/>(is the ouput hull, we omit to add set[0] voluntarily)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">var</span> jarvismarch = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( set , hull )</span> {</span>

		<span class="hljs-keyword">var</span> j , u , v , w , origin , sin , cos ;

		n = set.length ;

		origin = u = set[<span class="hljs-number">0</span>] ;

		j = <span class="hljs-number">1</span> ;

		<span class="hljs-keyword">while</span> ( <span class="hljs-literal">true</span> ) {

			v = set[j] ;

			<span class="hljs-keyword">for</span> ( ++j ; j &lt; n ; ++j ) {

				w = set[j] ;

				sin = sinsign( u , v , w ) ;

				<span class="hljs-keyword">if</span> ( sin === <span class="hljs-number">0</span> ) {

					cos = cossign( u , v , w ) ;

					<span class="hljs-keyword">if</span> ( cos &lt; <span class="hljs-number">0</span> ) v = w ;

				}

				<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( sin &lt; <span class="hljs-number">0</span> ) v = w ;

			}

			<span class="hljs-keyword">if</span> ( v === origin ) <span class="hljs-keyword">break</span> ;

			hull.push( v );

			u = v ;
			j = <span class="hljs-number">0</span> ;

		}

	} ;

	<span class="hljs-keyword">return</span> jarvismarch ;

} ;

exports.__jarvismarch__ = __jarvismarch__ ;</div></div></div></div></body></html>